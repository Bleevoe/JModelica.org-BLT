model Simple3
    Real x(start=1, fixed=true);
    Real y;
    Real z;
equation
    der(x) = x + y + z;
    y + z = x;
    -y + 2*z = 2*x;
end Simple3;

model Simple
	Real x(start=1, fixed=true);
	parameter Real p1 = 1;
	parameter Real p2 = 9;
equation
	if x > 0 then
		der(x) = -p2*x;
	else
		der(x) = p2*x;
	end if;
end Simple;

function p2_fcn
    input Real p1;
    output Real p2;
    Real t;
algorithm
	t := sqrt(p1)+2;
	p2 := if t > 2.3 then t^2 else t^2 + 0.05;
    return;
end p2_fcn;

model Simple2
    Real a(start=1, fixed=true);
    Real x;
    Real y;
    Real z;
equation
    der(a) = -x -y -z + 2;
    sqrt(x) + y + sqrt(z) = sqrt(a)+2;
    sqrt(x) + sqrt(y) = sqrt(a)+1;
    x + sqrt(z) = a+1;
end Simple;

model Fischer
    Real x(start=1, fixed=true);
    Real a;
    input Real b;
equation
    der(x) = x + a + b;
    sqrt(a^2+b^2)-a-b= 0;
end Fischer;

optimization Simple_Opt(objectiveIntegrand=x^2, finalTime=10)
    extends Simple;
end Simple_Opt;

optimization Triangular
	constant Integer n = 30;
	Real x[n](each start=1, each fixed=true);
	Real y[n];
equation
	der(x[1]) = x[1] - y[1];
	y[1] = x[1];
	for i in 2 : n loop
		der(x[i]) = x[i] - y[i];
		y[i] = x[i] + cos(y[i-1]);
	end for;
end Triangular;

optimization TriangularOpt(objectiveIntegrand=50*n*(x[n] - 2)^2 + u^2, finalTime=3)
	constant Integer n = 20;
	Real x[n](each start=1, each fixed=true);
	Real y[n];
	input Real u(min=-1, max=1);
equation
	der(x[1]) = x[1] - y[1] + u;
	y[1] = x[1];
	for i in 2 : n loop
		der(x[i]) = x[i] - y[i];
		y[i] = x[i] - cos(y[i-1]);
	end for;
end TriangularOpt;
